{"ast":null,"code":"var __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    var shaderLib = [{\n      vertUniforms: \"\",\n      vertCode: \"vTextureCoord = aTextureCoord;\",\n      fragUniforms: \"uniform vec4 uTextureClamp;\",\n      fragCode: \"vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\"\n    }, {\n      vertUniforms: \"uniform mat3 uTransform;\",\n      vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\n      fragUniforms: \"\",\n      fragCode: \"vec2 textureCoord = vTextureCoord;\"\n    }, {\n      vertUniforms: \"uniform mat3 uTransform;\",\n      vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\n      fragUniforms: \"uniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\",\n      fragCode: \"vec2 textureCoord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\" + \"\\ntextureCoord = (uMapCoord * vec3(textureCoord, 1.0)).xy;\" + \"\\ntextureCoord = clamp(textureCoord, uClampFrame.xy, uClampFrame.zw);\"\n    }];\n\n    var PictureShader = function (_super) {\n      __extends(PictureShader, _super);\n\n      function PictureShader(gl, vert, frag, tilingMode) {\n        var lib = shaderLib[tilingMode];\n\n        _super.call(this, gl, vert.replace(/%SPRITE_UNIFORMS%/gi, lib.vertUniforms).replace(/%SPRITE_CODE%/gi, lib.vertCode), frag.replace(/%SPRITE_UNIFORMS%/gi, lib.fragUniforms).replace(/%SPRITE_CODE%/gi, lib.fragCode));\n\n        this.bind();\n        this.tilingMode = tilingMode;\n        this.tempQuad = new PIXI.Quad(gl);\n        this.tempQuad.initVao(this);\n        this.uniforms.uColor = new Float32Array([1, 1, 1, 1]);\n        this.uniforms.uSampler = [0, 1];\n      }\n\n      PictureShader.blendVert = \"\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n}\\n\";\n      return PictureShader;\n    }(PIXI.Shader);\n\n    extras.PictureShader = PictureShader;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    var overlayFrag = \"\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cs2 = Cs * 2.0 - 1.0;\\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\\n    vec3 B;\\n    if (Cb.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cb.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cb.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\";\n\n    var HardLightShader = function (_super) {\n      __extends(HardLightShader, _super);\n\n      function HardLightShader(gl, tilingMode) {\n        _super.call(this, gl, extras.PictureShader.blendVert, overlayFrag, tilingMode);\n      }\n\n      return HardLightShader;\n    }(extras.PictureShader);\n\n    extras.HardLightShader = HardLightShader;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    function mapFilterBlendModesToPixi(gl, array) {\n      if (array === void 0) {\n        array = [];\n      }\n\n      array[PIXI.BLEND_MODES.OVERLAY] = [new extras.OverlayShader(gl, 0), new extras.OverlayShader(gl, 1), new extras.OverlayShader(gl, 2)];\n      array[PIXI.BLEND_MODES.HARD_LIGHT] = [new extras.HardLightShader(gl, 0), new extras.HardLightShader(gl, 1), new extras.HardLightShader(gl, 2)];\n      return array;\n    }\n\n    extras.mapFilterBlendModesToPixi = mapFilterBlendModesToPixi;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    var normalFrag = \"\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n\\n    vec4 sample = texture2D(uSampler[0], textureCoord);\\n    gl_FragColor = sample * uColor;\\n}\\n\";\n    var normalVert = \"\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n}\\n\";\n\n    var NormalShader = function (_super) {\n      __extends(NormalShader, _super);\n\n      function NormalShader(gl, tilingMode) {\n        _super.call(this, gl, normalVert, normalFrag, tilingMode);\n      }\n\n      return NormalShader;\n    }(extras.PictureShader);\n\n    extras.NormalShader = NormalShader;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    var overlayFrag = \"\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cb2 = Cb * 2.0 - 1.0;\\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\\n    vec3 B;\\n    if (Cs.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cs.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cs.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\";\n\n    var OverlayShader = function (_super) {\n      __extends(OverlayShader, _super);\n\n      function OverlayShader(gl, tilingMode) {\n        _super.call(this, gl, extras.PictureShader.blendVert, overlayFrag, tilingMode);\n      }\n\n      return OverlayShader;\n    }(extras.PictureShader);\n\n    extras.OverlayShader = OverlayShader;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    function nextPow2(v) {\n      v += v === 0 ? 1 : 0;\n      --v;\n      v |= v >>> 1;\n      v |= v >>> 2;\n      v |= v >>> 4;\n      v |= v >>> 8;\n      v |= v >>> 16;\n      return v + 1;\n    }\n\n    var PictureRenderer = function (_super) {\n      __extends(PictureRenderer, _super);\n\n      function PictureRenderer(renderer) {\n        _super.call(this, renderer);\n      }\n\n      PictureRenderer.prototype.onContextChange = function () {\n        var gl = this.renderer.gl;\n        this.drawModes = extras.mapFilterBlendModesToPixi(gl);\n        this.normalShader = [new extras.NormalShader(gl, 0), new extras.NormalShader(gl, 1), new extras.NormalShader(gl, 2)];\n        this._tempClamp = new Float32Array(4);\n        this._tempColor = new Float32Array(4);\n        this._tempRect = new PIXI.Rectangle();\n        this._tempRect2 = new PIXI.Rectangle();\n        this._tempRect3 = new PIXI.Rectangle();\n        this._tempMatrix = new PIXI.Matrix();\n        this._tempMatrix2 = new PIXI.Matrix();\n        this._bigBuf = new Uint8Array(1 << 20);\n        this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\n      };\n\n      PictureRenderer.prototype.start = function () {};\n\n      PictureRenderer.prototype.flush = function () {};\n\n      PictureRenderer.prototype._getRenderTexture = function (minWidth, minHeight) {\n        if (this._renderTexture.width < minWidth || this._renderTexture.height < minHeight) {\n          minHeight = nextPow2(minWidth);\n          minHeight = nextPow2(minHeight);\n\n          this._renderTexture.resize(minWidth, minHeight);\n        }\n\n        return this._renderTexture;\n      };\n\n      PictureRenderer.prototype._getBuf = function (size) {\n        var buf = this._bigBuf;\n\n        if (buf.length < size) {\n          size = nextPow2(size);\n          buf = new Uint8Array(size);\n          this._bigBuf = buf;\n        }\n\n        return buf;\n      };\n\n      PictureRenderer.prototype.render = function (sprite) {\n        if (!sprite.texture.valid) {\n          return;\n        }\n\n        var tilingMode = 0;\n\n        if (sprite.tileTransform) {\n          tilingMode = this._isSimpleSprite(sprite) ? 1 : 2;\n        }\n\n        var blendShader = this.drawModes[sprite.blendMode];\n\n        if (blendShader) {\n          this._renderBlend(sprite, blendShader[tilingMode]);\n        } else {\n          this._renderNormal(sprite, this.normalShader[tilingMode]);\n        }\n      };\n\n      PictureRenderer.prototype._renderNormal = function (sprite, shader) {\n        var renderer = this.renderer;\n        renderer.bindShader(shader);\n        renderer.state.setBlendMode(sprite.blendMode);\n\n        this._renderInner(sprite, shader);\n      };\n\n      PictureRenderer.prototype._renderBlend = function (sprite, shader) {\n        var renderer = this.renderer;\n        var spriteBounds = sprite.getBounds();\n        var renderTarget = renderer._activeRenderTarget;\n        var matrix = renderTarget.projectionMatrix;\n        var flipX = matrix.a < 0;\n        var flipY = matrix.d < 0;\n        var resolution = renderTarget.resolution;\n        var screen = this._tempRect;\n        var fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\n        screen.x = 0;\n        screen.y = 0;\n        screen.width = fr.width;\n        screen.height = fr.height;\n        var bounds = this._tempRect2;\n        var fbw = fr.width * resolution,\n            fbh = fr.height * resolution;\n        bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\n        bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\n        bounds.width = spriteBounds.width * resolution;\n        bounds.height = spriteBounds.height * resolution;\n\n        if (flipX) {\n          bounds.y = fbw - bounds.width - bounds.x;\n        }\n\n        if (flipY) {\n          bounds.y = fbh - bounds.height - bounds.y;\n        }\n\n        var screenBounds = this._tempRect3;\n        var x_1 = Math.floor(Math.max(screen.x, bounds.x));\n        var x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\n        var y_1 = Math.floor(Math.max(screen.y, bounds.y));\n        var y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\n        var pixelsWidth = x_2 - x_1;\n        var pixelsHeight = y_2 - y_1;\n\n        if (pixelsWidth <= 0 || pixelsHeight <= 0) {\n          return;\n        }\n\n        var rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\n\n        renderer.bindTexture(rt, 1, true);\n        var gl = renderer.gl;\n\n        if (renderer.renderingToScreen && renderTarget.root) {\n          var buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\n\n          gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\n          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\n        } else {\n          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\n        }\n\n        renderer.bindShader(shader);\n        renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\n\n        if (shader.uniforms.mapMatrix) {\n          var mapMatrix = this._tempMatrix;\n          mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\n\n          if (flipX) {\n            mapMatrix.a = -mapMatrix.a;\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\n          } else {\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\n          }\n\n          mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\n\n          if (flipY) {\n            mapMatrix.d = -mapMatrix.d;\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\n          } else {\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\n          }\n\n          shader.uniforms.mapMatrix = mapMatrix.toArray(true);\n        }\n\n        this._renderInner(sprite, shader);\n      };\n\n      PictureRenderer.prototype._renderInner = function (sprite, shader) {\n        var renderer = this.renderer;\n\n        if (shader.tilingMode > 0) {\n          this._renderWithShader(sprite, shader.tilingMode === 1, shader);\n        } else {\n          this._renderSprite(sprite, shader);\n        }\n      };\n\n      PictureRenderer.prototype._renderWithShader = function (ts, isSimple, shader) {\n        var quad = shader.tempQuad;\n        var renderer = this.renderer;\n        renderer.bindVao(quad.vao);\n        var vertices = quad.vertices;\n        var _width = ts._width;\n        var _height = ts._height;\n        var _anchorX = ts._anchor._x;\n        var _anchorY = ts._anchor._y;\n        var w0 = _width * (1 - _anchorX);\n        var w1 = _width * -_anchorX;\n        var h0 = _height * (1 - _anchorY);\n        var h1 = _height * -_anchorY;\n        var wt = ts.transform.worldTransform;\n        var a = wt.a;\n        var b = wt.b;\n        var c = wt.c;\n        var d = wt.d;\n        var tx = wt.tx;\n        var ty = wt.ty;\n        vertices[0] = a * w1 + c * h1 + tx;\n        vertices[1] = d * h1 + b * w1 + ty;\n        vertices[2] = a * w0 + c * h1 + tx;\n        vertices[3] = d * h1 + b * w0 + ty;\n        vertices[4] = a * w0 + c * h0 + tx;\n        vertices[5] = d * h0 + b * w0 + ty;\n        vertices[6] = a * w1 + c * h0 + tx;\n        vertices[7] = d * h0 + b * w1 + ty;\n        vertices = quad.uvs;\n        vertices[0] = vertices[6] = -ts.anchor.x;\n        vertices[1] = vertices[3] = -ts.anchor.y;\n        vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n        vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        quad.upload();\n        var tex = ts._texture;\n        var lt = ts.tileTransform.localTransform;\n        var uv = ts.uvTransform;\n        var mapCoord = uv.mapCoord;\n        var uClampFrame = uv.uClampFrame;\n        var uClampOffset = uv.uClampOffset;\n        var w = tex.width;\n        var h = tex.height;\n        var W = _width;\n        var H = _height;\n        var tempMat = this._tempMatrix2;\n        tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n        tempMat.invert();\n\n        if (isSimple) {\n          tempMat.append(mapCoord);\n        } else {\n          shader.uniforms.uMapCoord = mapCoord.toArray(true);\n          shader.uniforms.uClampFrame = uClampFrame;\n          shader.uniforms.uClampOffset = uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        var color = this._tempColor;\n        var alpha = ts.worldAlpha;\n        PIXI.utils.hex2rgb(ts.tint, color);\n        color[0] *= alpha;\n        color[1] *= alpha;\n        color[2] *= alpha;\n        color[3] = alpha;\n        shader.uniforms.uColor = color;\n        renderer.bindTexture(tex, 0, true);\n        quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n      };\n\n      PictureRenderer.prototype._renderSprite = function (sprite, shader) {\n        var renderer = this.renderer;\n        var quad = shader.tempQuad;\n        renderer.bindVao(quad.vao);\n        var uvs = sprite.texture._uvs;\n        var vertices = quad.vertices;\n        var vd = sprite.vertexData;\n\n        for (var i = 0; i < 8; i++) {\n          quad.vertices[i] = vd[i];\n        }\n\n        quad.uvs[0] = uvs.x0;\n        quad.uvs[1] = uvs.y0;\n        quad.uvs[2] = uvs.x1;\n        quad.uvs[3] = uvs.y1;\n        quad.uvs[4] = uvs.x2;\n        quad.uvs[5] = uvs.y2;\n        quad.uvs[6] = uvs.x3;\n        quad.uvs[7] = uvs.y3;\n        quad.upload();\n        var frame = sprite.texture.frame;\n        var base = sprite.texture.baseTexture;\n        var clamp = this._tempClamp;\n        var eps = 0.5 / base.resolution;\n        clamp[0] = (frame.x + eps) / base.width;\n        clamp[1] = (frame.y + eps) / base.height;\n        clamp[2] = (frame.x + frame.width - eps) / base.width;\n        clamp[3] = (frame.y + frame.height - eps) / base.height;\n        shader.uniforms.uTextureClamp = clamp;\n        var color = this._tempColor;\n        PIXI.utils.hex2rgb(sprite.tint, color);\n        var alpha = sprite.worldAlpha;\n        color[0] *= alpha;\n        color[1] *= alpha;\n        color[2] *= alpha;\n        color[3] = alpha;\n        shader.uniforms.uColor = color;\n        renderer.bindTexture(base, 0, true);\n        quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n      };\n\n      PictureRenderer.prototype._isSimpleSprite = function (ts) {\n        var renderer = this.renderer;\n        var tex = ts._texture;\n        var baseTex = tex.baseTexture;\n        var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        if (isSimple) {\n          if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n            if (baseTex.wrapMode === PIXI.WRAP_MODES.CLAMP) {\n              baseTex.wrapMode = PIXI.WRAP_MODES.REPEAT;\n            }\n          } else {\n            isSimple = baseTex.wrapMode !== PIXI.WRAP_MODES.CLAMP;\n          }\n        }\n\n        return isSimple;\n      };\n\n      return PictureRenderer;\n    }(PIXI.ObjectRenderer);\n\n    extras.PictureRenderer = PictureRenderer;\n    PIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\n    PIXI.CanvasRenderer.registerPlugin('picture', PIXI.CanvasSpriteRenderer);\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    var PictureSprite = function (_super) {\n      __extends(PictureSprite, _super);\n\n      function PictureSprite(texture) {\n        _super.call(this, texture);\n\n        this.pluginName = 'picture';\n      }\n\n      return PictureSprite;\n    }(PIXI.Sprite);\n\n    extras.PictureSprite = PictureSprite;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));\n\nvar PIXI;\n\n(function (PIXI) {\n  var extras;\n\n  (function (extras) {\n    var PictureTilingSprite = function (_super) {\n      __extends(PictureTilingSprite, _super);\n\n      function PictureTilingSprite(texture) {\n        _super.call(this, texture);\n\n        this.pluginName = 'picture';\n      }\n\n      return PictureTilingSprite;\n    }(extras.TilingSprite);\n\n    extras.PictureTilingSprite = PictureTilingSprite;\n  })(extras = PIXI.extras || (PIXI.extras = {}));\n})(PIXI || (PIXI = {}));","map":{"version":3,"sources":["/home/laferu/projetos/swipe/Platina-the-Wolf/components/platinaGameOneComponents/js/libs/pixi-picture.js"],"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","PIXI","extras","shaderLib","vertUniforms","vertCode","fragUniforms","fragCode","PictureShader","_super","gl","vert","frag","tilingMode","lib","call","replace","bind","tempQuad","Quad","initVao","uniforms","uColor","Float32Array","uSampler","blendVert","Shader","overlayFrag","HardLightShader","mapFilterBlendModesToPixi","array","BLEND_MODES","OVERLAY","OverlayShader","HARD_LIGHT","normalFrag","normalVert","NormalShader","nextPow2","v","PictureRenderer","renderer","onContextChange","drawModes","normalShader","_tempClamp","_tempColor","_tempRect","Rectangle","_tempRect2","_tempRect3","_tempMatrix","Matrix","_tempMatrix2","_bigBuf","Uint8Array","_renderTexture","BaseRenderTexture","start","flush","_getRenderTexture","minWidth","minHeight","width","height","resize","_getBuf","size","buf","length","render","sprite","texture","valid","tileTransform","_isSimpleSprite","blendShader","blendMode","_renderBlend","_renderNormal","shader","bindShader","state","setBlendMode","_renderInner","spriteBounds","getBounds","renderTarget","_activeRenderTarget","matrix","projectionMatrix","flipX","a","flipY","resolution","screen","fr","sourceFrame","destinationFrame","x","y","bounds","fbw","fbh","tx","ty","screenBounds","x_1","Math","floor","max","x_2","ceil","min","y_1","y_2","pixelsWidth","pixelsHeight","rt","bindTexture","renderingToScreen","root","readPixels","RGBA","UNSIGNED_BYTE","texSubImage2D","TEXTURE_2D","copyTexSubImage2D","NORMAL","mapMatrix","toArray","_renderWithShader","_renderSprite","ts","isSimple","quad","bindVao","vao","vertices","_width","_height","_anchorX","_anchor","_x","_anchorY","_y","w0","w1","h0","h1","wt","transform","worldTransform","c","uvs","anchor","upload","tex","_texture","lt","localTransform","uv","uvTransform","mapCoord","uClampFrame","uClampOffset","w","h","W","H","tempMat","set","invert","append","uMapCoord","uTransform","color","alpha","worldAlpha","utils","hex2rgb","tint","draw","TRIANGLES","_uvs","vd","vertexData","i","x0","y0","x1","y1","x2","y2","x3","y3","frame","base","baseTexture","clamp","eps","uTextureClamp","baseTex","isPowerOfTwo","_glTextures","CONTEXT_UID","wrapMode","WRAP_MODES","CLAMP","REPEAT","ObjectRenderer","WebGLRenderer","registerPlugin","CanvasRenderer","CanvasSpriteRenderer","PictureSprite","pluginName","Sprite","PictureTilingSprite","TilingSprite"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        var shaderLib = [\r\n            {\r\n                vertUniforms: \"\",\r\n                vertCode: \"vTextureCoord = aTextureCoord;\",\r\n                fragUniforms: \"uniform vec4 uTextureClamp;\",\r\n                fragCode: \"vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\"\r\n            },\r\n            {\r\n                vertUniforms: \"uniform mat3 uTransform;\",\r\n                vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\r\n                fragUniforms: \"\",\r\n                fragCode: \"vec2 textureCoord = vTextureCoord;\"\r\n            },\r\n            {\r\n                vertUniforms: \"uniform mat3 uTransform;\",\r\n                vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\r\n                fragUniforms: \"uniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\",\r\n                fragCode: \"vec2 textureCoord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\" +\r\n                    \"\\ntextureCoord = (uMapCoord * vec3(textureCoord, 1.0)).xy;\" +\r\n                    \"\\ntextureCoord = clamp(textureCoord, uClampFrame.xy, uClampFrame.zw);\"\r\n            }\r\n        ];\r\n        var PictureShader = (function (_super) {\r\n            __extends(PictureShader, _super);\r\n            function PictureShader(gl, vert, frag, tilingMode) {\r\n                var lib = shaderLib[tilingMode];\r\n                _super.call(this, gl, vert.replace(/%SPRITE_UNIFORMS%/gi, lib.vertUniforms)\r\n                    .replace(/%SPRITE_CODE%/gi, lib.vertCode), frag.replace(/%SPRITE_UNIFORMS%/gi, lib.fragUniforms)\r\n                    .replace(/%SPRITE_CODE%/gi, lib.fragCode));\r\n                this.bind();\r\n                this.tilingMode = tilingMode;\r\n                this.tempQuad = new PIXI.Quad(gl);\r\n                this.tempQuad.initVao(this);\r\n                this.uniforms.uColor = new Float32Array([1, 1, 1, 1]);\r\n                this.uniforms.uSampler = [0, 1];\r\n            }\r\n            PictureShader.blendVert = \"\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n}\\n\";\r\n            return PictureShader;\r\n        }(PIXI.Shader));\r\n        extras.PictureShader = PictureShader;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        var overlayFrag = \"\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cs2 = Cs * 2.0 - 1.0;\\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\\n    vec3 B;\\n    if (Cb.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cb.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cb.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\";\r\n        var HardLightShader = (function (_super) {\r\n            __extends(HardLightShader, _super);\r\n            function HardLightShader(gl, tilingMode) {\r\n                _super.call(this, gl, extras.PictureShader.blendVert, overlayFrag, tilingMode);\r\n            }\r\n            return HardLightShader;\r\n        }(extras.PictureShader));\r\n        extras.HardLightShader = HardLightShader;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        function mapFilterBlendModesToPixi(gl, array) {\r\n            if (array === void 0) { array = []; }\r\n            array[PIXI.BLEND_MODES.OVERLAY] = [new extras.OverlayShader(gl, 0), new extras.OverlayShader(gl, 1), new extras.OverlayShader(gl, 2)];\r\n            array[PIXI.BLEND_MODES.HARD_LIGHT] = [new extras.HardLightShader(gl, 0), new extras.HardLightShader(gl, 1), new extras.HardLightShader(gl, 2)];\r\n            return array;\r\n        }\r\n        extras.mapFilterBlendModesToPixi = mapFilterBlendModesToPixi;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        var normalFrag = \"\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n\\n    vec4 sample = texture2D(uSampler[0], textureCoord);\\n    gl_FragColor = sample * uColor;\\n}\\n\";\r\n        var normalVert = \"\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n}\\n\";\r\n        var NormalShader = (function (_super) {\r\n            __extends(NormalShader, _super);\r\n            function NormalShader(gl, tilingMode) {\r\n                _super.call(this, gl, normalVert, normalFrag, tilingMode);\r\n            }\r\n            return NormalShader;\r\n        }(extras.PictureShader));\r\n        extras.NormalShader = NormalShader;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        var overlayFrag = \"\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cb2 = Cb * 2.0 - 1.0;\\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\\n    vec3 B;\\n    if (Cs.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cs.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cs.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\";\r\n        var OverlayShader = (function (_super) {\r\n            __extends(OverlayShader, _super);\r\n            function OverlayShader(gl, tilingMode) {\r\n                _super.call(this, gl, extras.PictureShader.blendVert, overlayFrag, tilingMode);\r\n            }\r\n            return OverlayShader;\r\n        }(extras.PictureShader));\r\n        extras.OverlayShader = OverlayShader;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        function nextPow2(v) {\r\n            v += (v === 0) ? 1 : 0;\r\n            --v;\r\n            v |= v >>> 1;\r\n            v |= v >>> 2;\r\n            v |= v >>> 4;\r\n            v |= v >>> 8;\r\n            v |= v >>> 16;\r\n            return v + 1;\r\n        }\r\n        var PictureRenderer = (function (_super) {\r\n            __extends(PictureRenderer, _super);\r\n            function PictureRenderer(renderer) {\r\n                _super.call(this, renderer);\r\n            }\r\n            PictureRenderer.prototype.onContextChange = function () {\r\n                var gl = this.renderer.gl;\r\n                this.drawModes = extras.mapFilterBlendModesToPixi(gl);\r\n                this.normalShader = [new extras.NormalShader(gl, 0), new extras.NormalShader(gl, 1), new extras.NormalShader(gl, 2)];\r\n                this._tempClamp = new Float32Array(4);\r\n                this._tempColor = new Float32Array(4);\r\n                this._tempRect = new PIXI.Rectangle();\r\n                this._tempRect2 = new PIXI.Rectangle();\r\n                this._tempRect3 = new PIXI.Rectangle();\r\n                this._tempMatrix = new PIXI.Matrix();\r\n                this._tempMatrix2 = new PIXI.Matrix();\r\n                this._bigBuf = new Uint8Array(1 << 20);\r\n                this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\r\n            };\r\n            PictureRenderer.prototype.start = function () {\r\n            };\r\n            PictureRenderer.prototype.flush = function () {\r\n            };\r\n            PictureRenderer.prototype._getRenderTexture = function (minWidth, minHeight) {\r\n                if (this._renderTexture.width < minWidth ||\r\n                    this._renderTexture.height < minHeight) {\r\n                    minHeight = nextPow2(minWidth);\r\n                    minHeight = nextPow2(minHeight);\r\n                    this._renderTexture.resize(minWidth, minHeight);\r\n                }\r\n                return this._renderTexture;\r\n            };\r\n            PictureRenderer.prototype._getBuf = function (size) {\r\n                var buf = this._bigBuf;\r\n                if (buf.length < size) {\r\n                    size = nextPow2(size);\r\n                    buf = new Uint8Array(size);\r\n                    this._bigBuf = buf;\r\n                }\r\n                return buf;\r\n            };\r\n            PictureRenderer.prototype.render = function (sprite) {\r\n                if (!sprite.texture.valid) {\r\n                    return;\r\n                }\r\n                var tilingMode = 0;\r\n                if (sprite.tileTransform) {\r\n                    tilingMode = this._isSimpleSprite(sprite) ? 1 : 2;\r\n                }\r\n                var blendShader = this.drawModes[sprite.blendMode];\r\n                if (blendShader) {\r\n                    this._renderBlend(sprite, blendShader[tilingMode]);\r\n                }\r\n                else {\r\n                    this._renderNormal(sprite, this.normalShader[tilingMode]);\r\n                }\r\n            };\r\n            PictureRenderer.prototype._renderNormal = function (sprite, shader) {\r\n                var renderer = this.renderer;\r\n                renderer.bindShader(shader);\r\n                renderer.state.setBlendMode(sprite.blendMode);\r\n                this._renderInner(sprite, shader);\r\n            };\r\n            PictureRenderer.prototype._renderBlend = function (sprite, shader) {\r\n                var renderer = this.renderer;\r\n                var spriteBounds = sprite.getBounds();\r\n                var renderTarget = renderer._activeRenderTarget;\r\n                var matrix = renderTarget.projectionMatrix;\r\n                var flipX = matrix.a < 0;\r\n                var flipY = matrix.d < 0;\r\n                var resolution = renderTarget.resolution;\r\n                var screen = this._tempRect;\r\n                var fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\r\n                screen.x = 0;\r\n                screen.y = 0;\r\n                screen.width = fr.width;\r\n                screen.height = fr.height;\r\n                var bounds = this._tempRect2;\r\n                var fbw = fr.width * resolution, fbh = fr.height * resolution;\r\n                bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\r\n                bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\r\n                bounds.width = spriteBounds.width * resolution;\r\n                bounds.height = spriteBounds.height * resolution;\r\n                if (flipX) {\r\n                    bounds.y = fbw - bounds.width - bounds.x;\r\n                }\r\n                if (flipY) {\r\n                    bounds.y = fbh - bounds.height - bounds.y;\r\n                }\r\n                var screenBounds = this._tempRect3;\r\n                var x_1 = Math.floor(Math.max(screen.x, bounds.x));\r\n                var x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\r\n                var y_1 = Math.floor(Math.max(screen.y, bounds.y));\r\n                var y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\r\n                var pixelsWidth = x_2 - x_1;\r\n                var pixelsHeight = y_2 - y_1;\r\n                if (pixelsWidth <= 0 || pixelsHeight <= 0) {\r\n                    return;\r\n                }\r\n                var rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\r\n                renderer.bindTexture(rt, 1, true);\r\n                var gl = renderer.gl;\r\n                if (renderer.renderingToScreen && renderTarget.root) {\r\n                    var buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\r\n                    gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n                }\r\n                else {\r\n                    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\r\n                }\r\n                renderer.bindShader(shader);\r\n                renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\r\n                if (shader.uniforms.mapMatrix) {\r\n                    var mapMatrix = this._tempMatrix;\r\n                    mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\r\n                    if (flipX) {\r\n                        mapMatrix.a = -mapMatrix.a;\r\n                        mapMatrix.tx = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\r\n                    }\r\n                    else {\r\n                        mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\r\n                    }\r\n                    mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\r\n                    if (flipY) {\r\n                        mapMatrix.d = -mapMatrix.d;\r\n                        mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\r\n                    }\r\n                    else {\r\n                        mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\r\n                    }\r\n                    shader.uniforms.mapMatrix = mapMatrix.toArray(true);\r\n                }\r\n                this._renderInner(sprite, shader);\r\n            };\r\n            PictureRenderer.prototype._renderInner = function (sprite, shader) {\r\n                var renderer = this.renderer;\r\n                if (shader.tilingMode > 0) {\r\n                    this._renderWithShader(sprite, shader.tilingMode === 1, shader);\r\n                }\r\n                else {\r\n                    this._renderSprite(sprite, shader);\r\n                }\r\n            };\r\n            PictureRenderer.prototype._renderWithShader = function (ts, isSimple, shader) {\r\n                var quad = shader.tempQuad;\r\n                var renderer = this.renderer;\r\n                renderer.bindVao(quad.vao);\r\n                var vertices = quad.vertices;\r\n                var _width = ts._width;\r\n                var _height = ts._height;\r\n                var _anchorX = ts._anchor._x;\r\n                var _anchorY = ts._anchor._y;\r\n                var w0 = _width * (1 - _anchorX);\r\n                var w1 = _width * -_anchorX;\r\n                var h0 = _height * (1 - _anchorY);\r\n                var h1 = _height * -_anchorY;\r\n                var wt = ts.transform.worldTransform;\r\n                var a = wt.a;\r\n                var b = wt.b;\r\n                var c = wt.c;\r\n                var d = wt.d;\r\n                var tx = wt.tx;\r\n                var ty = wt.ty;\r\n                vertices[0] = (a * w1) + (c * h1) + tx;\r\n                vertices[1] = (d * h1) + (b * w1) + ty;\r\n                vertices[2] = (a * w0) + (c * h1) + tx;\r\n                vertices[3] = (d * h1) + (b * w0) + ty;\r\n                vertices[4] = (a * w0) + (c * h0) + tx;\r\n                vertices[5] = (d * h0) + (b * w0) + ty;\r\n                vertices[6] = (a * w1) + (c * h0) + tx;\r\n                vertices[7] = (d * h0) + (b * w1) + ty;\r\n                vertices = quad.uvs;\r\n                vertices[0] = vertices[6] = -ts.anchor.x;\r\n                vertices[1] = vertices[3] = -ts.anchor.y;\r\n                vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\r\n                vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\r\n                quad.upload();\r\n                var tex = ts._texture;\r\n                var lt = ts.tileTransform.localTransform;\r\n                var uv = ts.uvTransform;\r\n                var mapCoord = uv.mapCoord;\r\n                var uClampFrame = uv.uClampFrame;\r\n                var uClampOffset = uv.uClampOffset;\r\n                var w = tex.width;\r\n                var h = tex.height;\r\n                var W = _width;\r\n                var H = _height;\r\n                var tempMat = this._tempMatrix2;\r\n                tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\r\n                tempMat.invert();\r\n                if (isSimple) {\r\n                    tempMat.append(mapCoord);\r\n                }\r\n                else {\r\n                    shader.uniforms.uMapCoord = mapCoord.toArray(true);\r\n                    shader.uniforms.uClampFrame = uClampFrame;\r\n                    shader.uniforms.uClampOffset = uClampOffset;\r\n                }\r\n                shader.uniforms.uTransform = tempMat.toArray(true);\r\n                var color = this._tempColor;\r\n                var alpha = ts.worldAlpha;\r\n                PIXI.utils.hex2rgb(ts.tint, color);\r\n                color[0] *= alpha;\r\n                color[1] *= alpha;\r\n                color[2] *= alpha;\r\n                color[3] = alpha;\r\n                shader.uniforms.uColor = color;\r\n                renderer.bindTexture(tex, 0, true);\r\n                quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\r\n            };\r\n            PictureRenderer.prototype._renderSprite = function (sprite, shader) {\r\n                var renderer = this.renderer;\r\n                var quad = shader.tempQuad;\r\n                renderer.bindVao(quad.vao);\r\n                var uvs = sprite.texture._uvs;\r\n                var vertices = quad.vertices;\r\n                var vd = sprite.vertexData;\r\n                for (var i = 0; i < 8; i++) {\r\n                    quad.vertices[i] = vd[i];\r\n                }\r\n                quad.uvs[0] = uvs.x0;\r\n                quad.uvs[1] = uvs.y0;\r\n                quad.uvs[2] = uvs.x1;\r\n                quad.uvs[3] = uvs.y1;\r\n                quad.uvs[4] = uvs.x2;\r\n                quad.uvs[5] = uvs.y2;\r\n                quad.uvs[6] = uvs.x3;\r\n                quad.uvs[7] = uvs.y3;\r\n                quad.upload();\r\n                var frame = sprite.texture.frame;\r\n                var base = sprite.texture.baseTexture;\r\n                var clamp = this._tempClamp;\r\n                var eps = 0.5 / base.resolution;\r\n                clamp[0] = (frame.x + eps) / base.width;\r\n                clamp[1] = (frame.y + eps) / base.height;\r\n                clamp[2] = (frame.x + frame.width - eps) / base.width;\r\n                clamp[3] = (frame.y + frame.height - eps) / base.height;\r\n                shader.uniforms.uTextureClamp = clamp;\r\n                var color = this._tempColor;\r\n                PIXI.utils.hex2rgb(sprite.tint, color);\r\n                var alpha = sprite.worldAlpha;\r\n                color[0] *= alpha;\r\n                color[1] *= alpha;\r\n                color[2] *= alpha;\r\n                color[3] = alpha;\r\n                shader.uniforms.uColor = color;\r\n                renderer.bindTexture(base, 0, true);\r\n                quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\r\n            };\r\n            PictureRenderer.prototype._isSimpleSprite = function (ts) {\r\n                var renderer = this.renderer;\r\n                var tex = ts._texture;\r\n                var baseTex = tex.baseTexture;\r\n                var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\r\n                if (isSimple) {\r\n                    if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\r\n                        if (baseTex.wrapMode === PIXI.WRAP_MODES.CLAMP) {\r\n                            baseTex.wrapMode = PIXI.WRAP_MODES.REPEAT;\r\n                        }\r\n                    }\r\n                    else {\r\n                        isSimple = baseTex.wrapMode !== PIXI.WRAP_MODES.CLAMP;\r\n                    }\r\n                }\r\n                return isSimple;\r\n            };\r\n            return PictureRenderer;\r\n        }(PIXI.ObjectRenderer));\r\n        extras.PictureRenderer = PictureRenderer;\r\n        PIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\r\n        PIXI.CanvasRenderer.registerPlugin('picture', PIXI.CanvasSpriteRenderer);\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        var PictureSprite = (function (_super) {\r\n            __extends(PictureSprite, _super);\r\n            function PictureSprite(texture) {\r\n                _super.call(this, texture);\r\n                this.pluginName = 'picture';\r\n            }\r\n            return PictureSprite;\r\n        }(PIXI.Sprite));\r\n        extras.PictureSprite = PictureSprite;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\nvar PIXI;\r\n(function (PIXI) {\r\n    var extras;\r\n    (function (extras) {\r\n        var PictureTilingSprite = (function (_super) {\r\n            __extends(PictureTilingSprite, _super);\r\n            function PictureTilingSprite(texture) {\r\n                _super.call(this, texture);\r\n                this.pluginName = 'picture';\r\n            }\r\n            return PictureTilingSprite;\r\n        }(extras.TilingSprite));\r\n        extras.PictureTilingSprite = PictureTilingSprite;\r\n    })(extras = PIXI.extras || (PIXI.extras = {}));\r\n})(PIXI || (PIXI = {}));\r\n//# sourceMappingURL=pixi-picture.js.map"]},"metadata":{},"sourceType":"script"}